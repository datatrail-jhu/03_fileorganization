[["index.html", "03: Organizing Data Science Projects About this Course", " 03: Organizing Data Science Projects March, 2023 About this Course This course is part of a series of courses for DataTrail. DataTrail is a no-cost, paid 14-week educational initiative for young-adult, high school and GED-graduates. DataTrail aims to equip members of underserved communities with the necessary skills and support required to work in the booming field of data science. DataTrail is a fresh take on workforce development that focuses on training both Black, Indigenous, and other people of color (BIPOC) interested in the data science industry and their potential employers. Offered by the Johns Hopkins Bloomberg School of Public Health, in partnership with local non-profits and Leanpub, DataTrail combines a mutually-intensive learning experience (MILE) with a whole-person ecosystem of support to allow aspiring data scientists and their employers to succeed. DataTrail uses mutually-intensive learning DataTrail joins aspiring data science scholars and expert-level data scientist mentors in a mutually-intensive learning experience (MILE). In the DataTrail MILE: Scholars engage in cutting-edge technical and soft skills training needed to enter the data science field. Mentors engage in anti-racism and mentorship training needed to be impactful mentors and informed colleagues on diverse data science teams. The social connections created along the way will fuel job opportunities for scholars and foster a more diverse, equitable, and inclusive climate at the mentors’ institutions. "],["motivation.html", "Chapter 1 Motivation", " Chapter 1 Motivation Data science projects involve lots of files. There are files of data, files for code, files for documentation, figures, documents to communicate with other people. A surprising amount of doing data science really well is just being good at managing and organizing all of these files so that they are: Easy to find Easy to share Easy to understand Easy to update The reason that you need to make it easy to find and work with the files in your analysis is because data science is really closely related to communication. We use data is to understand the world and communicate that understanding. So when you are building a data science project, you should be thinking about who will be on the receiving end of your data analysis. While you are actively working on a project it is often easy to find any file you need off the top of your head. But the audience of your data analysis is not you, right now. One audience is other people who you will share your work with. They don’t know about all the different places you have stored data, or which piece of code to run first. You need to make it easy on them to be able to understand what you did. Two of your most common audiences in a data science project. Another audience that may surprise you when you are just starting, but will be familiar to any experienced data analyst is you. A twist on a famous saying about data science is: Your closest co-worker is you six months ago, but you don’t reply to emails. This is because it is really common for you to work on a data science project, present the results, and then move on to another project. But someone else is studying your results and might have questions and want you to make a change. So a few months later, when you’ve forgotten where everything is, they come back and ask you to make a minor change and you have to dive back in and figure out which files you need to look at. The reason you 6 months from now is one of your audience members. Whenever I teach this topic people are surprised I spend so much time on how to organize the setup of your projects or how to name your files. While this all seems like something very simple and common sense, this is where the biggest problems in data science often happen. Let me give you two quick examples. The first happened a few years ago. A research group from Duke university analyzed data about human genomes to try to develop a way to predict what chemotherapy each person should get based on their genetic code. They came up with what they thought was a good predictor and published it, then proceeded to start testing it in clinical studies. The exciting result, predicting chemotherapy success from genomic data. Researchers at MD Anderson got so excited about the result that they tried to find the data and code and do the same analysis as a first step to trying the predictor on their patients. But there was a problem, they couldn’t find the data or code. They tried getting it from the researchers at Duke, but it took months of back and forth getting a data set here, a file there, none of it too organized. Once they actually managed to get all of the files together and organized, they realized there were some major problems with the predictors that would probably put patients at risk! Two statisticians helped organize all the data and code from the project Ultimately this discovery shut down the clinical studies and led to a major lawsuit. While there were a lot of problems with the original analysis, the reason there was so much trouble was that the files and code weren’t organized so it took a long time to figure out the problems that would put patients at risk. It took a long time to do this organization and the delay meant erroneous clinical studies were carried out. Another famous example where file organization caused problems was with the scientific paper “Growth in a time of debt”. This paper was written by two Harvard economists and suggested that countries with a high level of debt have slow economic growth. Growth in the time of debt scientific paper. Unlike most academic papers this paper had a big impact! Many countries used this research to justify austerity measures that impacted social and healthcare programs around the world. But it turns out there were some choices the authors made that were questionable or changed their results. This mistake was so important that it was covered by popular shows like The Colbert Show on Comedy Central. The error was actually discovered by a student, but not until much much later. One reason it took so long is the data and analysis files weren’t easily available to everyone and organized in a way that the error could be easily identified. The errors in the analysis were discussed on the Colbert Report It isn’t just because of errors that you’d want to have organized files and projects. Whether it’s helping your future self, communicating a data science idea, or simply reducing your cognitive load, organizing projects from the start can save you a huge amount of time and hassle. As Jenny Bryan, one of the most famous data scientists in the world, says File organization and naming are powerful weapons against chaos. Jenny Byran says “File organization and naming are powerful weapons against chaos.” Another famous data scientist, Karl Broman, suggests that the best way to end up with a good file organization system has three steps. Step 1 slow down and make lots of notes for yourself. Step 2 have sympathy for your future self. Step 3 have a standard system that you understand A key challenge is that its sometimes hard to feel like file organization is “real work”. It isn’t coding, or making plots, or writing final documents. Sometimes, when working under a deadline, you will feel pressure to skip file organization in favor of quickly producing results and handing them off. But this never pays off in the long run, the results of poorly organized work almost always fail at some point further down the line. As a general rule of thumb it makes sense to budget 10-20% of the time you will be working on a data science project just to organizing and documenting your work. In the rest of this course we will cover one standard system for how to set up, organize, and navigate projects. Once you learn this system you can adapt it to work better for you, or try other ways of organizing your projects. 1.0.1 Slides and Video Automated Videos Slides "],["rstudio-and-projects.html", "Chapter 2 RStudio and Projects", " Chapter 2 RStudio and Projects You’ve seen RStudio in the first class in the sequence. Remember R is the main software that we are going to use to analyze data in this class. R is one of the two most popular languages for data science. We will learn a lot more about it throughout the courses, but here we are just going to use it to take a peak at the data you have created. R is a piece of software that is used for running computer code. RStudio is a company that makes a piece of software that works with R. RStudio makes it easier to create, save, share, and work with R code and data sets. RStudio is also useful for organizing projects and writing, organizing, and sharing your data science work. If you have a more traditional laptop you can download and install R and RStudio on your laptop. But this class is part of our DataTrail program where we will be teaching you how to do everything through a web browser. Fortunately RStudio also offers a web-based version of their software called RStudio Cloud. 2.0.1 Logging in to RStudio Cloud To use this software, open your web browser and navigate to the website https://rstudio.cloud/. Navigate to RStudio Cloud in your web browser You should see a screen that looks like this. You can click the button in the top right to log in. Log in to RStudio Cloud When you click Log In you will be offered options for Logging in, for our class you will log in with your Google Account so click on that option. Choose to log in with Google Then you will be asked to select which Google account or log in with a new Google account. Click on the Google account you have set up for this course. Choose your Google account You should now see a list of your projects. This is a list of the instructor’s projects, your list will be different. Choose your Google account Now you can create a new project to work on for the rest of this class. To create a new project click on New project in the upper right hand corner. Create a new project If you click on the name of the project - currently it will be Untitled Project - then you can rename it. Click to change the title of the project To make things simple let’s call it my_first_project. You will call it that by typing the name into the box for the project name. Rename the project my_first_project We will come back to this project later and talk about where to put files, data, and other parts of your project. But for now, if you want to see all the projects you have you can click on the words Your Workspace at the top left of the screen. Click on Your Workspace to see all of your projects If you want to return to a project, just click on the project name, for example by clicking on my_first_project. Click a project name to return to your project. You will have more than one project you may want to organize. Projects are organized into Spaces. A space is just a place that lists out multiple projects. To see your other spaces click on the menu bar indicated by the three stacked lines in the upper left. Click a project name to return to your project. If you have done the first course in the sequence then you belong at least to the Introduction to DataTrail Space. You can click on the name of this space in the upper left to see your projects in that space. Click a project name to return to your project. If you want to return to your original space, click again in the top left hand on the menu bar, then click on Your Workspace to return to your main set of projects. Now that you know how to create and navigate projects in the next lecture we will talk about organizing the files that fall within a project. 2.0.2 Slides and Video Automated Video Slides "],["setting-up-data-science-project-folders.html", "Chapter 3 Setting Up Data Science Project Folders 3.1 R Markdown 3.2 Including Plots", " Chapter 3 Setting Up Data Science Project Folders Once you have created a new project the next step is to organize and name the folders and files in that project. Naming and organizing files seems very boring, but it one of the most important parts of any data science project! Not having the files or the data available is one of the most common reasons that errors are missed in data science projects. 3.0.1 A project organization framework We will set up data science projects on RStudio Cloud. This is how you should set up every new data science project before you start doing any work. It will be much harder to set up after the project has started and files are scattered everywhere. Open your web browser and navigate to the website https://rstudio.cloud/. Go to RStudio Cloud Then log in and click on the project my_first_project. Click on my_first_project You should now see a screen that looks like this where there are three windows. The window in the lower right hand corner of the screen is the part that shows all the files you have in your project. Right now there shouldn’t be any files since we just created this project in the last lesson but didn’t do anything in the project. The RStudio Cloud interface showing the empty my_first_project Each time you start a new project you will need to create a set of folders for that project. You can create a new folder by clicking on New Folder at the top of the file window. Click New Folder to create a new folder. Then you can type in the name of the folder you want to create. First let’s create a folder called data. Name the folder data You should now see a folder called data in the file window. We now have a data folder in the files in the project. Next we will create a few more folders. For each one click the New Folder button, enter the name and click ok. The folders we need to create will be called figures, code, and products. Once you have created the folders you should see something like this. The top level folder structure for every new project These folders represent the four parts of any data science project. data - is the folder where you will put all the data you have collected or been given to analyze. figures - is where you will put plots, data pictures, and other images you have created to show data to other people. code - is where you will create code files for collecting, cleaning up, or analyzing data. products - this is the place where you will place any reports, presentations, or products you create for sharing with other people. Now that we have these folders in place the next thing you need to create is a README file. This is a file where you will describe all of the data and projects you will be doing. Every project should have a README file so that you can keep notes on what you have done during your project. You will add to this README as your project expands. To create the README file click File at the top left hand part of Rstudio. Click on File to create a new file. then over over New File to show the types of new files you can create. Move the cursor down and click on Text File. Hover over New File and move the cursor to Text File. You should see a new screen open with the title Untitled like this. An untitled text file. To save the file click on the disk icon in the top left hand corner of the screen. Click on the disk icon to save. Then you can title the file README.md and click Save to save it. Name the file README.md. You should now see the README.md file in your file list on the bottom right of the screen. You have now saved the file README.md. The next thing to do is fill in the README file with the initial description of your project. For now you can copy this text and paste it into your README file, then click the save button. # This is the README file for my_first_project The folders in this project are: * _data_ - is the folder where you will put all the data you have collected or been given to analyze. * _figures_ - is where you will put plots, data pictures, and other images you have created to show data to other people. * _code_ - is where you will create code files for collecting, cleaning up, or analyzing data. * _products_ - this is the place where you will place any reports, presentations, or products you create for sharing with other people. The README file can be used to describe both the high level organization as well as any important special cases about your project. It may be helpful to create additional README files in each subfolder to provide information specific to the files in that subfolder. You would want to link to them from the global README file you have just created. 3.0.2 The next level of organization This is the top level of the organization of a new data science project, but we will usually need to create a little more organization within each folder. For example if you click on the data folder you will see that it is empty. Click on the data folder. You can see at the top of the file organization tab that you are inside the folder data which is inside of the folder project. Click on the data folder. We need to create two new folders inside of the data folder, one for our raw data and one for our tidy data. You will learn a lot more about them later, but for now use the New Folder button Click on the New Folder button.. to create one folder called raw_data and another called tidy_data. Create raw_data and tidy_data folders. One way to write the folders we have now created is like this. data/ raw_data/ tidy_data/ code/ figures/ products/ Here you can see that the raw_data folder is inside of the data folder. You can now click on the word project at the top of the file window and it will take you back up one level so you will see the folders for data, code, figures, and products. Click on project to view the top level of the directory. The rest of the folders we will need can be written in that same way. The folder structure would look something like this. data/ raw_data/ tidy_data/ code/ raw_code/ final_code/ figures/ exploratory_figures/ explanatory_figures/ products/ writing/ We need to create the folders raw_code and final_code inside of the code folder. We also need the folders exploratory_figures and explanatory_figures in the figures folder. Finally we need the folder writing inside of the products folder. Using the same steps we did for creating the folders inside of the data folder, you can create the rest of the folders you will need to organize your data science project. Every time you start a new project you will need to do these steps to set up the folders you will need to store all the files you will be creating. In the next lesson we will talk about how to name the files that will go in these folders. A completed project folder. 3.0.3 Slides and Video Automated Video Slides 3.1 R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com. When you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: summary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 3.2 Including Plots You can also embed plots, for example: Note that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot. "],["creating-and-previewing-markdown-files-in-rstudio.html", "Chapter 4 Creating and Previewing Markdown Files in RStudio", " Chapter 4 Creating and Previewing Markdown Files in RStudio Because we’ll be working a lot in RStudio, it will be useful to learn how to work with Markdown and R Markdown files in RStudio. We’ll start first with creating Markdown files, which will be useful for making short reports or notes that do not contain R code. 4.0.1 Working with Markdown files We can create Markdown files in RStudio by going to the File menu and creating a new text file: Creating a new file This opens up a blank file in which you can type your notes in Markdown syntax: Adding Markdown text to the blank file When you are finished editing this document and wish to save, you can go to the File menu and select Save As to save your file: Saving the document Enter the name of your file, but be sure to include the file extension .md at the end: Entering a new filename When you press Enter, the file will be saved and any Markdown syntax used in your document will show up as color coded: The resulting saved file You can continue editing the document and saving with the Save option under the File menu. If you want to create a PDF of this document to share with someone, you can use the Preview functionality shown below: Previewing a Markdown document as a PDF If you are prompted to install packages in a dialog box that pops up, click “Yes”. After a few seconds a new browser window should pop up containing a preview of the resulting PDF document. If you wish to download this document, you can click the button at the top right: Downloading the PDF document Note that when you preview a Markdown file in this way, RStudio will add some header text to the top of your file. You don’t need to worry about this or delete this text. It just provides some useful setup information for the next time you use the Preview functionality. You can also view and download the PDF by clicking the file in the Files pane in RStudio. This will open the PDF in a new tab/window in your web browser. 4.0.2 Working with R Markdown files To create an R Markdown document in RStudio, go to the File menu and create a new R Markdown document: Creating a new R Markdown document If you are prompted to install packages in a dialog box that pops up, click “Yes” to proceed. You will see the following dialog box appear on your screen. Here you can enter the title of your document as well as your name. For the Default Output Format, we recommend choosing either the HTML or PDF option. After choosing your desired settings, click “OK”. Setting up options for the R Markdown document Then a new, partially filled-in R Markdown document will open: Editing the new R Markdown document You can edit the document by removing the default sections and adding your own notes and code. When you are ready to save, go to the File menu and click “Save As”. In the dialog box, you don’t need to worry about typing a file extension. RStudio will automatically add the .Rmd extension. Saving the R Markdown document In order to convert this document into a PDF document containing your code, plots, and text, you can click the Knit button: Knitting the R Markdown document Workflow recommendation: It is recommended that when you are working with your data with R commands that you type your commands in an R Markdown document instead of below in the Console. In this way, you already begin the process of documenting your steps. You can conveniently send commands from the document to the Console to be run by (1) ensuring that your cursor is on the line of code to be run and (2) hitting Ctrl and Enter simultaneously on the keyboard. You can also select several lines of code to be run and hit Ctrl + Enter. 4.0.3 Slides and Video Automated Videos Slides "],["introduction-to-markdown.html", "Chapter 5 Introduction to Markdown", " Chapter 5 Introduction to Markdown We learned briefly about Markdown and R Markdown documents in the previous lesson. Markdown is a basic markup language designed to be displayed on the web. With a few basic commands, you can create polished documents that can be used to: Communicate your results to others Provide daily/weekly reports of your employer 5.0.1 How to use Markdown If you know how to type you know how to use Markdown! Writing with Markdown is the exact same task as writing in a text editor like Microsoft Word. The only difference is that all the fancy buttons and options are removed and instead replaced with a series of commands that you can type to format your text. 5.0.2 Markdown Example Here’s a small example of what Markdown can do! You can see everything in this document is written as plain text, with just letters and basic symbols. An example markdown file Now you can see how that text appears when it is rendered in Markdown. Even though it was created with plain text, it appears with italics, bolding, different sized text, and even an image! A rendered markdown file 5.0.3 Main commands Three major formatting basics of Markdown are headers, bold and italicized text, and lists. Headers help you separate sections of your document, bold or italicized format allows you to emphasize important points in your document, and lists help you orderly arrange your ideas. 5.0.3.1 Headers Headers are straightforward. To create a header, you simply add a # sign right before the text you want to make a header. Keep in mind the # must be on the beginning of a new line (no text on the line before it). The more #’s you add before the text, the smaller the header will be. For example here is a list of headers you can use ordered from largest to smallest. # Largest ## Slightly less large ### Even less large #### Even smaller ##### Smaller still ###### Smallest shown here (but you can go smaller!) The reason why this did not register as a header is because it is formatted it as a comment. By inserting three tick marks before and after the block of text you wish to comment, it will not execute any formatting. Without the tick marks here is what we get! A rendered markdown file The headers look as we wanted them too. Thus headers should not be included in code chunks. If pound signs (#) are within a code chunk, Markdown will consider them to be comments, rather than headers. 5.0.3.2 Bolded and italicized text Creating bolded and italicized text is also very straightforward. Use a double asterisk (**) before and after the text you want to be bold and a single asterisk (*) before and after text you want to italicize. So in this sentence **what you want to bold** is shown **bolded** and *what you want to italicize* is shown in *italics*. See the results here: So in this sentence **what you want to bold** will be shown what you want to bold and *what you want to italicize* will be shown what you want to italicize. 5.0.3.3 Lists Lists are a useful way to organize your ideas or tasks. In Markdown, you can make your lists numbered or non-numbered. To make a numbered list, just put the number and a period in front of the item. As with headers, you do need to make sure your first number is on a new line (no text on the line before it!) 1. First item 2. Second item 3. Third item This becomes: First item Second item Third item For non-numbered lists, you can use your choice of asterisks (*), pluses (+), or minuses (-) to indicate list items: * First item * Second item OR + First item + Second item OR - First item - Second item All become: First item Second item You can create sub-items for your list by indenting (using multiple spaces or Tab) before the number or the asterisk/plus/minus. Make the number or symbol of the sub-item line up with the text of the item above it! 1. First item 2. Second item 1. Sub-item 2. Sub-item 3. Third item * Sub-item * Sub-item This becomes: First item Second item Sub-item Sub-item Third item Sub-item Sub-item If you want to cross off items on your list (as you do them, perhaps) you can create a strike-through using double tildes (~~). 1. ~~First item~~ 2. Second item 1. ~~Sub-item~~ 2. Sub-item This becomes: First item Second item Sub-item Sub-item 5.0.4 More complicated editing There are many more text modifiers you can use for Markdown. A short instructional guide can be found here. You will see some more of these commands later in this module, but you might want to bookmark the above link now for future reference! 5.0.5 Links Links to content on the internet can be included in a Markdown document as well. The format for a link is to put what you want your link to say in square brackets followed immediately by the web address where the link should go inside of parentheses, like this: [What you want your link to say](Web address where the link should go) For example if you want the link to go to www.google.com when clicked, then you’d replace the text in the parentheses and write: [What you want your link to say](www.google.com) This is what it would look like in your rendered Markdown file: What you want your link to say If you want to change the text of the link itself, you just change what’s in the square brackets. For example, you might want the sentence: If you don’t know the answer, you should look it up on Google, where the word Google would be a link to www.google.com. You could do that by putting Google into square brackets, with the web address www.google.com following immediately in parentheses, like this: If you don&#39;t know the answer, you should look it up on [Google](www.google.com). This would be shown as: If you don’t know the answer, you should look it up on Google. You can insert images in a Markdown document as well. This is done in a similar manner to links. For images you can add ![Image Caption](/path_to_image/image_name.png). The link can be the web location of an image or the local address of an image. For instance, if you type ![Yosemite National Park](https://commons.wikimedia.org/wiki/Yosemite_National_Park#/media/File:Half_Dome_from_Glacier_Point,_Yosemite_NP_-_Diliff.jpg) will show this. Yosemite National Park 5.0.6 Slides and Video Automated Videos Slides "],["managing-files-in-the-terminal.html", "Chapter 6 Managing Files in the Terminal", " Chapter 6 Managing Files in the Terminal As was discussed in the first lesson of this course, one of the most important aspects of being a productive data scientist is staying organized. And a big part of staying organized is in managing your files: knowing where they are located and manipulating them with ease. In these next few lessons, we will be getting you fluent in orienting yourself in file systems in two areas: the Terminal and R/RStudio. In this lesson, we will focus on working with the Terminal. 6.0.1 What is the Terminal? The Terminal is an interface to the operating system of a computer. That is, it provides a way for you to type commands in order to perform actions on a computer. For example, there are commands to create new files and folders and to open files and folders. On your computer, you are familiar with using your mouse to perform such actions. When you are working with data on RStudio Cloud, however, you will not be able to use your mouse for everything that you’ll want to do. It will be important for you to become comfortable with using the Terminal as a place for purely text-based commands. In RStudio Cloud, the Terminal is located in the tab next to the Console. Locating the Terminal in RStudio Cloud When you click on this tab, you will see a pane that looks as follows: The Terminal prompt You will always see a string of text at the beginning of the line. This is called the Terminal prompt. To the right of the dollar sign, you will be entering your commands. The Terminal is going to be extremely important for efficient management of your files. You will also use it extensively in the next course when you learn about version control systems and GitHub because it is the primary interface for working with those tools. 6.0.2 Why manage files in the Terminal? As we’ve discussed, the Terminal is a command-based interface to a computer operating system. This turns out to be a very flexible and fast way to manage your files once you become comfortable with a few commands. Let’s say that you wanted to make a copy of a folder. Whether on RStudio Cloud or on Google Drive, you would need to go through a series of clicks and typing to find that folder, copy it, and rename it. Within the Terminal, this can all be achieved with a single command. 6.0.3 File system example and vocabulary To set up an example of a file system that we’ll be using throughout this lesson, let’s take a look again at the folder structure/directory structure that you created earlier in this course. Within a project folder, it is recommended that you set up the folders within as below. We will be working with this directory setup in an RStudio Cloud project. Directory structure In future courses, whenever you write code and run commands within R to work with data, or whenever you use Git commands to document updates to your files, you will be working in a particular location. To know your location within a file system is to know exactly what folder you are in right now. The folder that you are in right now is called the working directory. Your current working directory in the Terminal may be different from your current working directory in R and may yet even be different from the folder shown in the Files pane of RStudio. The focus of this lesson is on the Terminal, so we will not discuss working directories within R until the next lesson. Knowing your working directory is important because if you want to tell Terminal to perform some actions on files in other folders, you will need to be able to tell the Terminal where that folder is. That is, you will need to be able to specify a path to that folder. A path is a string that specifies a sequence of folders to traverse in order to end up at a final destination. The end of a path string may be a file name if you are creating a path to a file. If you are creating a path to a folder, the path string will end with the destination folder. In a path, folder names are separated by forward slashes /. For example, let’s say that your current working directory in the Terminal is the raw_code directory, and you wish to navigate to the exploratory subfolder within the figures folder to see the graphics you’ve created. Definitions: working directory and path There are two types of paths that can lead to that location. The first is called a relative path which gives a path to the destination folder based on where you are right now (in raw_code). A little later in this lesson you’ll learn how to construct relative paths. Relative path Alternatively, you can specify an absolute path. An absolute path starts at the root directory of a file system. The root directory does not have a name like other folders do. It is specified with a single forward slash / and is special in that it cannot be contained within other folders. In the current file system, the root directory contains a folder called cloud, which contains a folder called project. This project folder contains the four main folders that you learned about in a previous lesson. A little later in this lesson you’ll learn how to construct absolute paths. Absolute path Analogy: The root directory is analogous to a town square, a universal starting location. The desired destination location might be the baker. An absolute path specifies how to reach the bakery starting from this universal starting location of the town square. However, if we are in the library right now, a relative path would specify how to reach the bakery from our current location in the library. This could be pretty different than the path from the town square. 6.0.4 Important commands Now that you have some vocabulary, we can delve into details about creating and using paths with different Terminal commands for managing files. 6.0.4.1 Where am I right now? If you want to know your current working directory with the Terminal (what folder you are in), you can use the pwd command by typing pwd at the Terminal prompt and hitting Enter. This stands for “print working directory”, and it prints the absolute path to your current location. In the example below we are in the project folder within the cloud folder. We can determine that this is an absolute path because it starts with a forward slash /. pwd command 6.0.4.2 What is in this folder? If you want to know what files and folders are contained within your current directory, you can use the ls command. This stands for “list”, and it lists the files and folders within the current directory. If you just use the ls command without any options, the contents will be displayed horizontally across lines. If you add the -lh option with a space after the initial ls command, the output is displayed more nicely. The l part displays the results in a longer form with more information than just the file name. The h part displays the file sizes in a human-readable format. The most important pieces of information are in the last three columns, which display the file or folder size, the date the file or folder was last modified, and the name of the file or folder. You can also list the contents of a specific folder by specifying an absolute or relative path after the main ls command. In the example below, we list the contents of the products subfolder using a relative path. ls command When you use ls without specifying any path, it displays the contents of the current working directory. You can get the same results by specifying a period . for the path, as shown below. The period stands for the current working directory. ls command 6.0.4.3 Change directory If you would like to change your current working directory, you can use the cd command. This stands for “change directory” and moves you to the folder that you specify with a path after cd. If I want to move to the raw_data folder, I can specify this with a relative path data/raw_data/ because I am currently in the cloud/project/ folder. When you type these paths, it will be incredibly useful to use the tab completion feature of Terminal. With tab completion, you can partially type part of a folder or file name and hit tab to automatically fill in the remainder of the name. So here I can type cd da, and when I hit tab, this will automatically complete to cd data/ because there are no other files or folders in this folder that start with da. From here I can type cd data/r and hit tab to automatically fill in the complete command cd data/raw_data/. Tab completion tries to fill in as much as possible but may not fill in completely if you have multiple folders that start with the same letters. If I had a folder called dance in the project folder, tab completion of cd da would not proceed further, but cd dat would. Try this out when you’re typing at the Terminal prompt - it will save you a lot of time! In addition, if you want to move one directory up, for instance going from the folder data/raw_data to data, you can use the command cd ... cd command I could also have specified an absolute path with cd /cloud/project/data/raw_data/. In this case, because of my initial working directory, both the relative and absolute paths take me to the same folder. Note that we have checked our updated working directory with the pwd command. Also note that this path matches the part of the Terminal prompt just before the dollar sign. This is a way to doubly verify where you are within the file system. cd command If you try to change directory to a nonexistent folder, you will get an error message that looks as below: Error with the cd command 6.0.4.3.1 Absolute vs. relative paths Let’s go a little bit further with exploring the difference between absolute and relative paths. Let’s say that I have some code in the raw_code folder, and in that code, I want to create some exploratory graphics in the exploratory folder. Using our file system on RStudio Cloud, the path to the exploratory folder could be specified with the absolute path /cloud/project/figures/exploratory/. However, if someone else copies over the four main folders (data, code, figures, and products) onto their own computer and puts them inside folders with different names, this absolute path will not work. Why? Because this person happens to have the root and work folders instead of the cloud and project folders. Absolute paths are not portable Rather than using an absolute path, a robust way to specify the path to the exploratory folder is with a relative path. In this way, our code will work on all computers, which is essential for data science work. Specifying this relative path is a little more complicated than we have seen earlier because we have to traverse up through some folders that contain our current working directory and down through another set of folders. To specify the folder containing the current working directory, we use ../. When we are in the raw_code folder, the ../ specifies the code folder because it is the one directly containing our current directory. However, to enter the figures folder, we need to go up one more level to the folder that contains the code folder. On our RStudio Cloud, this is the project folder, but for this other person, it is the work folder. We can go up one more folder level with another ../. So the complete relative path from raw_code to exploratory is ../../figures/exploratory/. Relative vs absolute paths Let’s look at one more example to reinforce these ideas. Our current working directory is the raw_code directory. We want to specify a path to the final_code directory. There are several ways to do achieve this, but the first listed below is the most straightforward. ../final_code/ ../../code/final_code/ ../../../work/code/final_code/ Additional example for relative paths 6.0.4.4 Cycling through previous commands Often when working in the Terminal, you will want to run the same or similar commands that you have run earlier. For example, you may want to change directories, list files, and then repeat this process as you change to other directories. You can avoid typing commands over and over by using the up and down arrow keys at the Terminal prompt. Hitting the up arrow key once pulls up the last command that you entered. Hitting the up key twice pulls up the command you entered two times ago. Now hitting down will pull up your last command again. You can keep hitting up and down to cycle through your previous commands. Try this out when you are typing at the Terminal! 6.0.4.5 The wildcard operator In several different Terminal commands, it can be useful to specify only part of a file or folder name. For example, if we go to the raw_code folder and use the ls command, we see that there are 4 files. In larger projects, there may be many more files and we might not want to view all of them. We can specify certain patterns of files to list after the main ls command using part of the file name combined with the * wildcard operator. This operator matches any number of characters. So to list only files that start with “clean”, we can use ls -lh clean*. To only list files that contain “dataset1”, we can use ls -lh *dataset1* to match any characters on either side of the “dataset1” pattern. This will be useful when you work more with GitHub, starting in the next course. Wildcard operator 6.0.4.6 Copying files and folders Copying files and folders will come up often during your work. You may want to copy a messy code file to a new file to begin cleaning it up. It may be useful to do this for an entire folder. To copy in Terminal, we can use the cp command. To copy one file, the syntax is cp path_to_original_file path_to_new_file The path to the original file and the path to the new file can be absolute or relative paths. In the path to the new file, you can specify a different file name to rename it. In the example below, the first command cp clean_dataset1.R ../final_code/ copies the clean_dataset1.R file to the final_code folder and keeps the same name. The second command cp clean_dataset1.R ../final_code/clean_dataset1_renamed.R specifies the relative path and a new file name. When we list the contents of the final_code folder, we see both the originally named file and the renamed file. Copying a single file We can combine copying with the wildcard operator to copy multiple files. This does not rename the files. We can also copy multiple files into a directory by naming the files explicitly. That is cp analyze* ../final_code/ achieves the same as cp analyze_dataset1.R analyze_dataset2.R ../final_code/. Copying multiple files To copy a folder, we must specify the recursive option -r in order to copy all of the files and folders inside the one being copied. In the example below, using cp final_code/ publication_code doesn’t work, but cp -r final_code/ publication_code does work. Note that a final forward slash at the end of final_code and publication_code is optional. In these examples, you will see the trailing forward slash when tab completion was used to speed up typing. Copying a folder 6.0.4.7 Moving files and folders In the process of organizing your files, you will undoubtedly need to move files and folders to different locations. To move files and folders in Terminal, we can use the mv command. This command also renames files and folders. Similar to the copy command, the syntax for moving one file is mv path_to_original_file path_to_new_file Just as with copy, the path to the original file and the path to the new file can be absolute or relative paths. In the path to the new file, you can specify a different file name to rename it. In the example below, the first command mv ../final_code/clean_dataset1_renamed.R . moves the clean_dataset1_renamed.R file to the current working directory (indicated by the period at the end of the command) and keeps the same name. The next two commands mv clean_dataset1.R tidy_dataset1.R and mv clean_dataset2.R tidy_dataset2.R rename the files in the working directory to start with tidy instead of clean. When we list the contents of the working directory, we see both the moved file and the two renamed files. Moving a single file We can combine moving with the wildcard operator to move multiple files. This does not rename the files. We can also move multiple files into a directory by naming the files explicitly. This is achieved with mv tidy_dataset1.R tidy_dataset2.R ../raw_code/. Moving multiple files To move a folder into another folder, we use the same syntax for moving a single file: mv path_to_folder_being_moved destination_path In the example below, we achieve this with mv raw_code/ publication_code/. We can also rename a folder by specifying a new name for the destination path. In the example, we achieve this with mv publication_code/ pub_code. Moving and renaming a folder 6.0.4.8 Deleting files and folders To delete files and folders in the Terminal, we can use the rm command, which stands for remove. To remove a single file, the syntax is as follows: rm path_to_file_to_delete To remove multiple files, you can specify paths to multiple files separated by spaces or use the wildcard operator. Examples are shown below. Deleting files To delete a folder, we must specify the recursive option -r in order to recursively delete all of the files and folders inside the one being deleted. This is exactly as we had to do with copying a folders. In the example below, using rm final_code/ doesn’t work, but rm -r final_code/ does work. Deleting a folder Be very careful when deleting files and folders because this action is irreversible! In particular, rm * will delete all files in the current working directory. If you are using the wildcard operator, test your wildcard pattern with an ls command before deleting anything. 6.0.4.9 Creating files and folders To create an empty file in the Terminal, we can use the touch command with touch path_to_file. The file will be empty, but it serves as a placeholder in case you decide to later open and edit the file. Creating a new file To create a new directory in the Terminal, we can use the mkdir command, which stands for “make directory.” After mkdir, type the path to the folder that we want to create. Creating a new directory 6.0.5 Summary The Terminal is an interface to the operating system of a computer that you will be using to manage your files and to interface with GitHub, which will be covered in the next course. The essentials of navigating in the Terminal include knowing exactly what folder you are in with the pwd command and changing folders with the cd command. The essentials of managing files in the Terminal includes listing files with the ls command, copying them with cp, moving them with mv, and deleting them with rm. When you work with Git commands in the next course, you will be using the Terminal to navigate to the correct working directory and using Git commands to track changes you make in specified files. In order to specify those files, you will need to be comfortable with entering relative paths, as we covered in this lesson. Because Git commands allow use of the * wildcard operator, it will be useful for you to become comfortable with writing wildcard patterns to match multiple files. You can always test your patterns with an ls command to see that the desired files are being listed. To create new files, you can use the touch command, and to create new folders, you can use the mkdir command. Overall, managing your files in the Terminal will save you a lot of time in the long run compared to manual clicking. 6.0.6 Additional Resources The ls command The cp command The mv command The rm command 6.0.7 Slides and Video Automated Videos Slides "],["managing-files-in-r.html", "Chapter 7 Managing Files in R", " Chapter 7 Managing Files in R In this lesson, we will continue our tour of ways in which you will be managing files as a data scientist. In the previous lesson, you learned about the Terminal and its command-based interface to the file system on RStudio Cloud. In this lesson, you will learn in small part about the R programming language and in large part about specific tools within R to manage files. You will learn much more about R for its capabilities in data science work in future courses. 7.0.1 Why manage files in R? As a data scientist, you will find it very useful to automate the management and organization of files. In the previous lesson, you learned about the power of the Terminal to run commands that allow you to more efficiently manage files than standard clicking and typing. However, for some tasks with larger scale data projects, it will be easier to work with files programmatically in R rather than at the Terminal. Why? Because R is programming language, you will be able to manage files in complex situations where your actions are dependent on lot of other information. For example, if you are working with hundreds of different files, moving them to a location that depends on information in the files is much easier with a programming language such as R rather than at the Terminal. Also, in order to completely document your work in going from raw files to finished products, a good approach is to combine your data work in R (to be covered in later courses) with your file organization work in R. 7.0.2 Navigating to R in RStudio Cloud When you open a project in RStudio Cloud, you will see a Console pane that is immediately next to the Terminal pane. Usually this pane is automatically open when you open a project. The &gt; that you see in the R console is called the R prompt. It is analogous to the Terminal prompt in that it is where you can type and enter R commands. Locating the Console in RStudio Cloud 7.0.3 File system setup We’re going to be using the same file system setup as in the previous lesson. The file system is shown below. Only the raw_data and raw_code folders contain files. In this lesson, we will be working within this file system to illustrate useful file manipulation functions within R. Example file system 7.0.4 Important functions 7.0.4.1 What is my working directory? Recall from the previous lesson that a working directory is the folder that you are currently in within a file system. We discussed that the working directory within the Terminal may be different from the working directory within R, and both of these may be different from the Files pane in RStudio. To determine your working directory in R, you can use the getwd() function, which stands for “get working directory.” When you type getwd() at the R prompt and hit enter, you will see the absolute path to your working directory displayed in quotes on a new line. As with working in the Terminal, knowing the working directory in R is important because when you run code that refers to other files, R will search for those files relative to this directory. getwd() is analogous to pwd in the Terminal. getwd() 7.0.4.2 Set the working directory In Terminal you learned about the cd command to change the current (working) directory. In R, use the setwd() function, which stands for “set working directory.” Inside the parentheses, type an absolute or relative path in quotes. Just as in the Terminal, tab completion can save typing time and help prevent incorrect spelling. When you hit tab after typing part of a path, RStudio provide a drop down menu of files and folders that fit what you have typed. You can select between them with the arrow keys or your mouse and hit enter to autocomplete. Note also that the absolute path to the current working directory is displayed in the status bar beneath the Console tab. The working directory is not automatically updated or reflected in the Files pane however. Additionally, the Console and the Terminal do not talk to one another. When you set your working directory in one, it does not change the working directory in the other. This is important to keep in mind when you’re working. In fact, the working directory in the Terminal, Console, and Files tab can all be different. setwd() 7.0.4.3 What is in this folder? In Terminal you learned about the ls command for listing the contents of a directory. In R, use the list.files() function. Without anything in the parentheses, R will list the files in the current working directory. Otherwise, you can include a relative or absolute path in quotes. In the example below we see that using no path gives the same result as specifying the current directory with a period. When we list the files in the raw_code directory, four files are listed. The numbers in the square brackets just help us count in the displayed output. An option when using list.files() is to type full.names = TRUE after the initial path and a comma. Doing this displays the full relative paths to those files. Note that if the path ends in a forward slash, there will be two forward slashes before the filename in the output. This is not a problem, but if you prefer to not have two forward slashes, omit the trailing forward slash when you type the path. list.files() 7.0.4.4 Create a file In Terminal you learned about the touch command to create a blank file. In R, use the file.create() function. In parentheses, provide a path to the file to create. If this is successful, R will display TRUE and FALSE otherwise. You can verify that the file has been created by using list.files(). As in Terminal, you can quickly cycle through recent commands using the up and down arrow keys. file.create() 7.0.4.5 Moving and renaming a file In Terminal you learned about the mv command for moving and renaming files. In R, use the file.rename() function. In the parentheses, you provide two paths separated by a comma. The first path is the path to the origin file. The second path is the path to the destination file. In the first example, we move the data3.txt file and keep the same name by specifying a different sequence of folders at the beginning of the second path and keeping the same file name. In the second example, we move and rename simultaneously by specifying a different sequence of folders and a different file name. If the renaming is successful, R will display TRUE and FALSE otherwise. file.rename() 7.0.4.6 Copy a file In Terminal you learned about the cp command for copying and renaming files. In R, use the file.copy() function. This function works similarly to file.rename() in that you have to supply the path to the original file first and the path to the destination second. If the copy is successful, R will display TRUE and FALSE otherwise. The first example copies the data3_renamed.txt file to the data3.txt file. In the second example, we try to do this again but fail because data3.txt already exists, and R will not overwrite a file by default. In example 3, we specify overwrite = TRUE after the two paths and a comma to explicitly overwrite the data3.txt file. file.copy() 7.0.4.7 Remove a file In Terminal you learned about the rm command for deleting files. In R, use the file.remove() function. In the parentheses, provide a path to the file you want to delete in quotes. If the deletion is successful, R will display TRUE and FALSE otherwise. file.remove() 7.0.4.8 Does a file exist? In Terminal you used the ls command to list the contents of a directory for verifying what files and folders are present. If you want to check whether a particular file exists, you can use the file.exists() function in R. In the parentheses, provide a path to the file of interest. In the first example, we show the usage for a single file. For data1.txt, R displays TRUE because this file exists. In the second example, we show the usage if you want to check the existence of multiple files. The multiple files are specified in what is called a character vector. The two paths are separated by a comma in the c() function which is the concatenation function. In this case, R displays TRUE then FALSE because data2.txt exists but data4.txt does not. You will learn much more about character vectors and the c() function in later courses devoted to R. Note that the other functions we covered in this lesson (except getwd() and setwd()) can also be used on multiple files by supplying character vectors of paths instead of single paths. You will have a chance to try these out when you learn more about R and begin working on projects. file.exists() In this lesson, you learned about R functions that are analogous to Terminal commands for managing files. As you work on projects, you’ll gain an appreciation for the benefits of managing files using a programming language. 7.0.5 Slides and Video Automated Videos Slides "],["using-paths-in-code.html", "Chapter 8 Using Paths in Code", " Chapter 8 Using Paths in Code Now that you know what a file path is and how to navigate to different directories using both the Terminal and the R Console, we’ll discuss how to include file paths when coding. 8.0.1 Relative and absolute paths Relative and absolute paths were discussed in an earlier lesson in this course. This is a very brief review: 8.0.1.1 Relative paths Relative paths give a path to the destination folder based on where you are right now (your current working directory). Relative paths 8.0.1.2 Absolute paths Absolute paths give a path to the destination folder based on the root directory of a file system. Absolute paths 8.0.2 Directions analogy So, to return to analogy of giving someone directions. Imagine that your friend plans to go from the town square, then to the library, and finally to the bakery. In this analogy, the town square represents the root directory, a universal starting location. If your friend is currently at the library and asks you for directions, you would likely tell them how to go from the library (where they are) to the bakery (where they want to go). This represents a relative path – taking you from where you are currently to where you want to be. Alternatively, you could give them directions from the Town square, to the library, and then to the bakery. This represents an absolute path, directions that will always work in this town, no matter where you are currently, but that contain extra information given where your friend is currently. Directions and paths analogy 8.0.3 Paths in projects In this course, you’ve learned how to organize your project folders and name your files for every data science project you complete. Setting up projects in this way not only helps keep you organized and your file naming consistent, but it also sets you up to easily refer to many different files while you’re writing code. Often you’ll find yourself writing some code in your raw_code folder, but you’ll want to read in some data that are in your raw_data folder. The good thing is that since everything for this project is together in a subfolders within a single project folder, you can accomplish this easily. 8.0.3.1 Use relative paths in projects To easily reference back to a dataset in your raw_data folder where you have a file called dataset.csv, you’ll want to use a relative path. You’ll set your path relative to the project folder. In this example, you will have set your project directory as /cloud/directory and you would reference your relative path data/dataset.csv. relative path to dataset.csv Since you’ve already defined where your starting point is for this project (/cloud/directory), you’ll be able to and should refer to every folder and every file easily with relative paths. 8.0.3.2 Relative paths make sharing projects easier The reason relative paths for each project are the correct approach is because if you share this project with someone else with a different computer, you would likely share the project file and all the subdirectories. If you were to share this with someone else and relative paths were used throughout all the code in your project, that new person would be able to follow along and run all your code without any problems. Using relative paths enables sharing However, you are not likely to (and shouldn’t!) share all the contents of your entire computer with another person. If you had used absolute paths that work for your computer, rather than relative paths, none of the paths will make any sense on the person’s computer whom you’ve shared your content with. To enable sharing with someone else, you should always use relative paths in your code that are relative to the project folder. Thankfully, there’s an easy way in R to make that happen! Absolute paths prohibit sharing 8.0.4 The here package We haven’t yet discussed what an R package is or what the basic commands in R are. However, we have covered file organization at this point and how to navigate within R. With that knowledge, we’re now going to discuss how to use the here package. While we’ll define in more depth what packages are, at this point, think of packages as something that allows you to accomplish something that you wouldn’t have been able to otherwise or that wouldn’t have been as easy to accomplish without the package. We’re going to discuss using a single R package now, called here. To get started using the here package (or any R package!), it first has to be installed (using the install.packages() function) and then loaded in (using the library() function). Note that the package name in the install.packages() function has to be in quotes but for library() it doesn’t have to. The code to copy and paste into your R console is below: install.packages(&quot;here&quot;) library(here) 8.0.5 Why to use here Okay, so if we’re discussing packages later, why discuss this one package now? Well, here is a package specifically designed to help you deal with file organization when you’re coding. This package allows you to define in which folder all your relative paths should begin within a project. 8.0.5.1 Setting your project directory After installing and loading the here package, to set your project directory using here(), you’ll simply type the command here(). You’ll notice that the output of here() and getwd() in this case is the same; however, what they’re doing behind the scenes is different. getwd() - shows the directory you are in currently here() - sets the directory to use for all future relative paths The here() function is what you want to use to set your project directory so that you can use it for future relative paths in your code. While in this case it also happened to be in the same directory you were in, it doesn’t have to be this way. The here() function looks to see if you have a .Rproj file in your project. If then sets your base directory to whichever directory that file is located. here() sets your project directory for future reference using here() So, if we were to change our current directory and re-type here() in the Console, you’ll note that the output from here() does not change because it’s still looking for the directory where .Rproj is. here() does not care what your current working directory is Note: In cases where there is no .Rproj file, here() will look for files other than a .Rproj file. You can read about those cases in the fine print here. But for most of your purposes, here() will behave as we just discussed. 8.0.5.2 Get files paths using here() After setting your project folder using here(), R will then know what folder to use to define any and all other paths within this project. For example, if you wanted to include a path to a file named “intro_code.R” in your raw_code directory, you would simply specify that in your code like this: here(&quot;code&quot;, &quot;raw_code&quot;, &quot;intro_code.R&quot;) This code says start from where I’ve already defined the project starts (here()), then look in the folders code and then raw_code, for the file “intro_code.R.” The syntax is simplified when using here(). Each subdirectory or file in the path is in quotes and simply separated by commas within the here() function, and voila you have the relative path you’re looking for relative to here(). The output from this code includes the correct file path to this file, just as you wanted! using here to get a file path 8.0.5.3 Where you should use this You should use here() to set the base project directory for each data science project you do. And, you should use relative paths using here() throughout your code any time you want to refer to a different directory or sub-directory within your project using the syntax we just discussed. 8.0.6 Additional Resources here, here, by Jenny Bryan here documentation, by Kirill Müller 8.0.7 Slides and Video Automated Videos Slides "],["how-to-work.html", "Chapter 9 How to Work", " Chapter 9 How to Work 9.0.1 Why Organize? In the previous lessons we learned about how to organize our files into folders and how to name our files and folders. Doing this has the following benefits: Easier collaboration: You will see that as a data scientist, you will have to work with teams of other data scientists most of the time. Organizing makes collaboration a lot easier. Lower likelihood of making mistakes: When you organize, it is easier for you and others to see where you might have made a mistake before it’s too late. Easier recall: Going back to your analysis and understanding what you have done in 6 months or a year or even later will be a lot easier. If your project is not organized, it is very likely that you go back to your analysis and do not understand what you or your collaborator have previously done. More transparency and honesty on your part: This is because you make it easier for others to go through your files and replicate your analysis. Using the raw_data folder for keeping the raw data untouched is important especially if you don’t have a second copy of the raw data. If you make changes to and tidy up the raw data within your analysis, make sure you do not overwrite your raw data. It is important that you keep the raw data intact and instead add the cleaned and tidy data to the tidy_data folder. Next is using the raw_code folder for keeping your preliminary code. Let’s see what we mean by that. When you are doing the preliminary part of your analysis, code without any constraint, that is do not worry much about how nice your code looks or whether it is self-explanatory. Don’t devote much of your brain power to commenting or tidying at first. Save this kind of code in the raw_code folder since it’s raw and most of the time no one but you understands it. Later on, when you clean your code and make it more understandable, you can save bits and pieces of it in your final code file in the final_code folder. 9.0.2 The README File Once you have a file structure in place, it’s best to write a README file. This file should explain how the code and data are organized as well as how they are related. In other words, explain what is what. For each filename, we recommend to have a short description of what the file is for. You can also have a description of how the data were obtained or collected including links or references to publication or other documentation. Mention people involved with the project, and provide contact information of at least one of the collaborators. A good idea is to update the README file as you work. As you create new files and folders, add their descriptions to the README file so you can keep track of what you are working on. You might also make a more detailed README file, which includes a list of variables, units of measurement of each variable, definition of code and symbols used to deal with missing data, Licenses or restrictions on the content of the project including the data, and information about how others should cite your analysis. 9.0.3 Using Comments Our next piece of advice is that use comments within your code. Commenting in R is done by adding the pound sign (#). If you add the pound sign at the beginning of each line, R will not read that line as code and will instead skip it. So you can add your explanations about each chunk of code using the pound sign. This is an example of commenting: # calculates the products of a vector and a matrix # checks if they can be multiplied first function (x, y){ if (dim(x)[2] != length(y)) { stop(&quot;Can&#39;t multiply matrix%*%vector because the dimensions are wrong&quot;) } product &lt;- matrix %*% vector return(product) } Note that the first line describes what the function does. Commenting is helpful especially when the code is more complicated and harder to understand. Keep comments short and informative and avoid inserting comments for code that have an obvious purpose, i.e. don’t add comment for a line of code that adds two variables). 9.0.4 Version control Always make sure your changes are saved and even more importantly that all your files are version controlled. Version control is common practice in data science. Don’t worry if you don’t know much about it. In a future course we’ll cover version control in much more detail. 9.0.5 Write in a Modular Way One mistake in writing code is to have everything in one file. This is bad practice since fixing bugs and replicating the analysis would be much harder. Therefore, it is recommended that you write code in a modular way so that each group of code that do similar things can be put in a single file and the master file calls these individual files. The result is a much cleaner and shorter master file. 9.0.6 Draft and Final Versions When working on a data science project you will start with data in the data/raw_data folder and you will start with code in the code/raw_code folder. Most of your early analysis will be done within the code/raw_code folder. When you are first starting out on a project it makes sense to work quickly, exploring a data set or a problem and figuring out what is going on. Don’t worry about the details at this stage! The goal is to just try to figure out what is going on with the data you are working on. Within your code/raw_code folder you can try to have a numbering system as we described in the file naming section. You might create a file called 00_first_analysis.R and start doing some analysis that might be messy or incomplete. You would keep track of what you working on in your README file or in a lab notebook at regular intervals. Once you have figured things out and know what analysis you want to do you will go back through and take pieces of the analysis and code you created in the code/raw_code folder, clean it up, and put it into final documents that go into the code/final_code and products/writing folders. That way you have a record of every messy analysis you did, but you also have a nice cleaned up version that you can share with other people. The key take home message is that you should start fast, trying out things and not being afraid to make mistakes. This is what will go in your raw folders. Then, once you have figured out what you want to do more clearly, you will make final versions that are clear and easier to communicate. Budget about 20% of your time keeping track of a bulleted list of the things that you need to do and the things that you do day to day across all your data science projects. This is to help you organize and remember what you did when for future references. There are various tools for keeping track of your projects. One of them is Benchling. Benchling can be used for workflow management and tracking your project in a collaborative way. 9.0.7 Slides and Video Automated Videos Slides "],["about-the-authors.html", "About the Authors", " About the Authors These credits are based on our course contributors table guidelines.     Credits Names Pedagogy Lead Content Instructor(s) FirstName LastName Lecturer(s) (include chapter name/link in parentheses if only for specific chapters) - make new line if more than one chapter involved Delivered the course in some way - video or audio Content Author(s) (include chapter name/link in parentheses if only for specific chapters) - make new line if more than one chapter involved If any other authors besides lead instructor Content Contributor(s) (include section name/link in parentheses) - make new line if more than one section involved Wrote less than a chapter Content Editor(s)/Reviewer(s) Checked your content Content Director(s) Helped guide the content direction Content Consultants (include chapter name/link in parentheses or word “General”) - make new line if more than one chapter involved Gave high level advice on content Acknowledgments Gave small assistance to content but not to the level of consulting Production Content Publisher(s) Helped with publishing platform Content Publishing Reviewer(s) Reviewed overall content and aesthetics on publishing platform Technical Course Publishing Engineer(s) Helped with the code for the technical aspects related to the specific course generation Template Publishing Engineers Candace Savonen, Carrie Wright Publishing Maintenance Engineer Candace Savonen Technical Publishing Stylists Carrie Wright, Candace Savonen Package Developers (ottrpal) John Muschelli, Candace Savonen, Carrie Wright Art and Design Illustrator(s) Created graphics for the course Figure Artist(s) Created figures/plots for course Videographer(s) Filmed videos Videography Editor(s) Edited film Audiographer(s) Recorded audio Audiography Editor(s) Edited audio recordings Funding Funder(s) Institution/individual who funded course including grant number Funding Staff Staff members who help with funding   ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.3 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2023-03-20 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.3) ## bookdown 0.24 2022-02-15 [1] Github (rstudio/bookdown@88bc4ea) ## callr 3.4.4 2020-09-07 [1] RSPM (R 4.0.2) ## cli 2.0.2 2020-02-28 [1] RSPM (R 4.0.0) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.14 2019-05-28 [1] RSPM (R 4.0.3) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.6.1 2022-01-22 [1] CRAN (R 4.0.2) ## htmltools 0.5.0 2020-06-16 [1] RSPM (R 4.0.1) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## knitr 1.33 2022-02-15 [1] Github (yihui/knitr@a1052d1) ## lifecycle 1.0.0 2021-02-15 [1] CRAN (R 4.0.2) ## magrittr 2.0.2 2022-01-26 [1] CRAN (R 4.0.2) ## memoise 1.1.0 2017-04-21 [1] RSPM (R 4.0.0) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.3.4 2020-08-11 [1] RSPM (R 4.0.2) ## purrr 0.3.4 2020-04-17 [1] RSPM (R 4.0.3) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## rlang 0.4.10 2022-02-15 [1] Github (r-lib/rlang@f0c9be5) ## rmarkdown 2.10 2022-02-15 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.2 2020-11-15 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2022-02-15 [1] Github (R-lib/testthat@e99155a) ## usethis 2.1.5.9000 2022-02-15 [1] Github (r-lib/usethis@57b109a) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2022-02-15 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["references.html", "Chapter 10 References", " Chapter 10 References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
